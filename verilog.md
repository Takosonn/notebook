# Verilog HDL



## 1.Verilog历史

 硬件描述语言 Hardware Description Language，代码脚本的方式，比图形化的效率高；

VHDL：欧洲、中国高校等；Verilog：美国；

Verilog语法比较简单，使用随意，VHDL严谨，语法要求高；

Verilog HDL最初在1983年被一家公司开发；

1992年选为标准；



## 2.综合

Verilog是硬件描述语言，描述，使用综合器对Verilog代码进行解释后变成电路；

QUARTUS, ISE, VIVADO等都是综合器；

可综合设计：可以变成电路的；

综合就是把编写的rtl代码转换成对应的电路；

综合要做的事情：编译rtl代码，从库里选择用到的门器件，把这些期间按照逻辑搭建成门电路；

设计的时候要确保所写的代码是可以综合的；



## 3.仿真

一般情况下可以认为没经过仿真的代码都是有bug的；

通过输入激励给设计文件看输出，看是否正确，模拟最真实的情况；

Verilog定义的语法大部分都是用来仿真的；

while、initial、force、fork、#n仅用于仿真，严禁在设计中使用；

所有的信号类型定义都用reg和wire；

除法和求余运算的电路面积较大，不建议使用；



## 4.模块结构

模块套模块，自上而下展开；

以module开始endmodule结束；

端口（input，output，inout）、参数（parameter）；

input [ 信号位宽-1 : 0 ];

对一个系统的顶层模块采用结构化设计，即顶层分别调用了各个功能模块；

模块例化：一个模块能在另一个中被使用；



## 5.信号类型

连线类型wire；

wire 	[7:0] 表示该wire型信号的位宽为8位；

无符号数的最大值2^n^-1，位宽为n；

寄存器类型reg；

reg 	[位宽-1:0]；

没有定义信号类型默认为wire；

没有定义范围，默认为1位；

使用always设计的信号都定义为reg，其他都wire；



## 6.组合逻辑

assign 是连续赋值语句，将一个变量的值不间断地赋给另一个变量；

assign a = b (?) c；

always 是条件循环语句，是一直、总是的意思；

always @（敏感事件）begin

​	程序语句

end

always	@(a or b or d)begin

​	if(sel == 0)

​		c = a + b;

​	else

​		c = a + d;

​	end

当a、b、c任一发生变换时就执行一次，sel变化不执行，因为不是敏感事件；

可以用 * 来代替程序语句中的所有信号：always   @(*)begin

逻辑组合，信号变化结果立即变化：always   @(posedge clk)begin

always @(A or B)begin

时序逻辑：信号边沿触发，即信号上升沿或下降沿才变化的always，此时信号clk是时钟；



## 7.数字进制

<位宽> ‘ <基数><数值>

如  4‘d11 = 4’b1011

位宽就是二进制位数；

基数表示 进制；

若基数是b，数值可以是0，1，x，X，z，Z；

一切的根本是二进制，在FPGA中，小数、有符号数都可以对应二进制；



## 8.不定态

x和z，如1’bx ，1‘bz，没有实际的电平对应这两者；

用来表示设计者的意图，告诉仿真器和综合器如何解释这段代码

X态Z态称为不定态，常用于无关项，无论0和1；

在设计中尽量解释清楚，在电路层面是没有不定态的；

如果在仿真中出现不定态，设计者需要分析是否需要关心它的电平是多少；；

常用来节省代码量；



## 9.高阻态

表示行为，表示不驱动这个信号（不给0也不给1）；

assign data	 = (wr_en == 1)?wr_data:1'bz;

assign rd_data = data;

三态门，使能 wr_en、写数据wr_data、读数据rd_data以及输出data；

当使能有效时wr_data = data，使能无效时不驱动；



## 10.算数运算符

always@(*)begin

​		c = a+b;    //加法器

end

always@(*)begin

​		c = a-b;    //减法器

end

乘法	*，就是多个加法运算；

除法	/，求余	%，包含加法、乘法、减法、移位等多个运算，要尽量避免；

如 a/2 就是a右移一位，a/4就是右移两位，数尽量为2^n^；



## 11.信号位宽

最终取决于等号左边信号的位宽，也就是被赋值的一方的位宽；

比方说a的位宽为3，则010001运算结果保留低三位001；

运算的最终结果，低位保存，高位丢弃；



## 12.补码

当出现进位的时候结果要扩展一个位宽才是正确的；

补码转换：增加符号位，正数保持不变，负数符号位保持不变，数值取反+1；

在FPGA中所有的数据都是以补码的方式保存的；

在计算前，要根据常识，预计结果的最大最小值；

要将加数、减数的位宽扩展为一致；



## 13.逻辑运算符

逻辑与：C = A && B，逻辑或C = A || B;，非！；

1位逻辑与：A 和 B 都为1时C为1；

多位逻辑与：A和B都不为0时C为1；

1位逻辑或：A B其中一个非0时C为1；

多位逻辑或：A和B其中一个非0时C为1

逻辑运算可看作一个整体，最终的结果只有0或1；

多位逻辑操作数可看作整体，每一位都是0才是0值；

逻辑运算符低于算术运算符（<、>），！的优先级大于另外两个；

在工作中要多用括号来区分优先级；



​                                                                                                                       
